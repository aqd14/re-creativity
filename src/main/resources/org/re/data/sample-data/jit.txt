Refinement and Resolution of Just-in-Time Requirements in Open Source Software: A Case Study
Anh Quoc Do and Tanmy Bhowmik Department of Computer Science and Engineering Mississippi State University, USA
Email: aqd14@msstate.edu, tbhowmik@cse.msstate.edu
Abstract—Just-in-time (JIT) requirements are defined as not following the traditional requirement engineering approach, in- stead focusing on elaboration when the implementation begins. In this paper, we analyze six JIT requirements, both functional and non-functional, from three successful open source software projects, including Firefox, Lucene, and Mylyn, to explore the common activities that shaped those requirements. We identify a novel refinement and resolution process that all studied require- ments followed from requirement inception to their complete realization and subsequent release. This research provides new insights into how project teams create quality features from simple initial descriptions of JIT requirements. Our study also initiates some captivating questions regarding JIT requirements to trigger further in-depth research in this area.
Keywords: Just-in-time; refinement; resolution; functional; non-functional
I. INTRODUCTION
Open-source software (OSS) community has been expand- ing rapidly over the last decade. According to traditional requirements engineering (RE), the requirements should be fully specified upfront so that the developers can proceed with the implementation activities. Recent RE research, however, has determined that there is no significant correlation between successful OSS projects and definitive software documents [1] and such a traditional RE approach is often found to be rather ineffective in OSS paradigm [2]. Consequently, the notion of “just-in-time” (JIT) requirements, characterized by lightweight representation and continuous refinement of requirements, has recently emerged to bridge the gap between theory and practice [3].
Recent research has provided valuable insights about the characteristics and dominance of JIT requirements in suc- cessful OSS systems [2], [4]–[8]. Ernst and Murphy [2] emphasized the tightly coupled nature of elaboration and implementation of JIT requirements and indicated that the requirements are informally captured in a lightweight form, e.g., user stories, and further refined during implementation. Heck and Zaidman [5] pointed out the importance of JIT trait specially when requirements are likely to change and can not be documented in details before implementation. With a few exceptions such as [2], much of recent JIT RE research has mostly studied functional requirements [9] whereas non- functional requirements [10] have remained largely unex-
plored. Furthermore, little is known about the individual activ- ities that shape the functional and non-functional requirements in JIT RE process.
In this position paper, we present a case study involving three successful large-scale OSS systems—Firefox, Lucene, and Mylyn—and detail the common trend we observe in their JIT RE process. In particular, we pick one functional and one non-functional [10] JIT requirement from each system, analyze associated comments and artifacts recorded over the issue tracking systems, identify individual activities performed by the stakeholders during the resolution process, and further present a detailed workflow associated with JIT RE. In what follows, Section II highlights recent studies on JIT require- ments. Section III presents our study setup and methodology. Section IV details the refinement and resolution process we observe along with additional discussion, and Section V dis- cussing the limitations and our future work.
II. BACKGROUND AND RELATED WORK
The term “just-in-time” (JIT) was popularized by Toyota and other Japanese firms in the 1950s referring to meeting customer demand at the right time and in the exact amount with minimized inventory cost [11]. Inspired by the idea of JIT in the manufacturing industry, RE researchers have utilized the notion of JIT requirements to stress the efficient implementation achieved through reduced effort in creating documentation. To that end, Michael Lee [7] detailed the analysis process of an agile methodology and outlined two fundamental principles of JIT requirements analysis (JITRA): “identify when they are needed” and “only at the level of detail required”.
Research related to JIT requirements has recently emerged. Studying four different OSS communities, Scacchi [4] initially discovered eight kinds of ‘software informalisms’ playing critical role in OSS RE. Scacchi et al. [1] further explored that a new OSS requirement is often a functionality or feature informally captured through a story telling or a user experience at the initial stage. In a seminal work on JITRA, Ernst and Murphy [2] studied three requirements from three large-scale OSS systems and indicated the fact that OSS requirements are initially captured in an informal manner and later elab- orated during implementation. In a recent work, Heck and
TABLE I
SELECTED JUST-IN-TIME REQUIREMENTS
   ID
Requirement
 Category
 Participants
  Comments
  FIREFOX-480148
Restore visible tabs first when restoring session
 Functional
 14
  34
  FIREFOX-767676
Implement Security UI Telemetry
 Non-functional
 12
  68
  LUCENE-2507
Automaton spellchecker
 Functional
 3
  16
  LUCENE-2127 LUCENE-2215
Improved large result handling
 Non-functional
 15
  66
  MYLYN-256699
Show description in preview mode for existing tasks with editable descriptions
 Functional
 7
  68
  MYLYN-116487
Create performance test harness
 Non-functional
 6
  45
       Zaidman [5] identified a set of quality criteria and proposed a framework to assess the quality of JIT requirements. Ana- lyzing the resolution time of JIT requirements from two OSS systems, Bhowmik and Reddivari [8] recently reported two interesting observations about JIT RE activities and product release time. Despite these research initiatives, knowledge in JIT RE for OSS systems is fairly limited. To further expand the literature, in this position paper, we highlight the individual activities involved in the refinement and resolution of JIT requirements by analyzing both functional and non-functional requirements.
III. STUDY SETUP
In this study, we investigate requirements from three large- scale OSS projects: Firefox, Lucene, and Mylyn. There are several key criteria that lead to this selection. First, these are stable and successful projects. Therefore, studying their features can possibly uncover some good latent practice. Second, they were previously studied in JIT RE research [2], [8], thus providing valuable insights about the JIT aspects of their requirements. Finally, their requirements and associated data required to conduct our study are publicly available on the issue tracking systems such as Jira (for Lucene) or Bugzilla (for Firefox and Mylyn).
A. Mozilla Firefox
Mozilla Firefox1, first released in November 2004, is a popular open source web browser developed by the Mozilla Foundation. Firefox is well-known for its extensibility with many useful add-ons and security enhancements compared to its main rival at that time, Internet Explorer 6 from Microsoft.
B. Lucene
Apache Lucene2 is a Java-based open-source software li- brary to support full text indexing and searching the content for cross-platform applications. Lucene aims to provide scalable high-performance indexing mechanisms and supports power- ful, efficient searching algorithms.
1 https://www.mozilla.org/en-US/firefox 2 https://lucene.apache.org
C. Mylyn
Mylyn3 is an open-source task-focused interface for Eclipse that concentrates on reducing information overload and in- creasing productivity for the users. To that end, Mylyn pro- vides relevant task views and monitors user’s activity to make multitasking more convenient in a timely manner.
D. Selecting Candidate Requirements
Each project contains a tremendous number of require- ments making it impractical to study all of them within the scope of this paper. Therefore, we apply the critical case sampling technique [12], i.e., selecting a single case or small number of cases that can yield important information about the phenomenon of interest. Using this technique, we collect prospective requirements that are likely to reveal a concrete picture about JIT RE refinement and resolution process. The selection criteria used to pick the sample requirements include: 1) requirements should start with a lightweight representa- tion (i.e., user stories), and 2) requirements should trigger a significant discussion among stakeholders (i.e., number of participants and comments associated with the requirements).
Table I layouts an overview for chosen requirements by applying the aforementioned criteria. To generalize our study, we select one functional and one non-function requirement from each project. In what follows, we detail the individual activities we notice during the refinement process for the selected JIT requirements until they are fully implemented. We also report on the observed relationships among those activities and the collaboration among stakeholders that shape a JIT requirement and its corresponding implementation.
IV. RESULTS AND DISCUSSION
This section presents JIT RE refinement and resolution process we explore from our study. In our observation, all the studied requirements follow an iterative and evolutionary approach. Figure 1 presents the general refinement and reso- lution process that we find common among the requirements. Subsequently, we specify each activity in the process and then include further discussions based on our investigation.
3 http://www.eclipse.org/mylyn
   Start
Initialize Requirement
   Testing
Review
      Develop & Commit the Patch
Elaborate Req Refine Iplm
    Voting Pass Public Release Veto
Cancel End
      Fig. 1. Refinement and Resolution in Just-in-time Requirements.
A. Refinement and Resolution Steps
Initialize Requirement. As an essential part in RE ac- tivities, requirement initialization marks the inception of JIT requirements. For each requirement, one authorized developer (called reporter) creates a high-level feature request in the issue tracking system with a short and clear title. In addition, the reporter provides a brief description to guarantee that all other developers have an original idea about the requirement specification before moving forward to the review activity.
Review. The review takes place after the requirement is reported. This activity includes two courses of action.
Requirement Review: When the requirement is proposed, there is an informal review to verify if the requirement is eli- gible for implementation. In FIREFOX-480148, for example, one participant argues that this feature had been implemented before and should not be integrated into the current system (this claim, however, was later disproved). If the requirement passes through verification, others can contribute to further elaboration, making it fit for the project roadmap.
Implementation Review: Whenever a developer commits a patch, he/she notifies others by posting a comment over the issue tracking system. The contributors download committed patch to their local machines, examine and run the code for further testing and review. By doing so, other developers gain crucial insights into the committed patch and provide constructive feedback for improvement, if necessary.
Beside above reviews, each project might have exclusive standards to examine the qualification of the requirement and its associated implementation. In Firefox, for instance, patches
that are module-crossed, have a high impact on the existing system, or are likely to involve security aspects, will have to undergo an additional super-review that consists of crucial expert-reviews for critical standards.
Elaborate Requirement / Refine Implementation. We notice in our study that JIT requirements and their associated implementation are highly coupled. Usually, JIT requirements are not well-defined upfront before implementation begins. Therefore, some misconceptions naturally exist during imple- mentation. After this, we specify some typical problems that developers addressed in the JIT requirements we examined.
Requirement Elaboration: At first, a JIT requirement is stated as a compact title with a short description. Unsur- prisingly, reporters sometimes have difficulties anticipating all suitable uses for the users. Hence, there might be some unpleasant user experiences when the feature is developed at the beginning. For instance, in MYLYN-256699, users can only trigger editing description by double-clicking on the text field. This approach seemed inappropriate where several developers pointed out that the common practice should be one-click when setting cursor whereas double-click is used for selecting text. As a result, the developer changed to one- click editing and everyone came to an agreement. We identify that the requirement gradually reaches consensus and fulfills project roadmap in this manner.
Implementation Refinement: Implementation plays an im- portant role in allowing a JIT requirement to be integrated into the system. For all three projects, quality code is found to be absolutely crucial. For each committed patch, developers examine the code, identify potential flaws, if any, and provide suggestions to improve the current implementation. The main aspects that developers focus on to refine the implementation are: (1) Correctness: the implementation works the way spec- ification states (e.g., LUCENE-2127, MYLYN-256699); (2) Performance: the implementation operates efficiently (e.g., LUCENE-2127, MYLYN-116487); and (3) Coding Style: the implementation follows the coding rules specified for a certain project (e.g., FIREFOX-767676, FIREFOX-480148).
As we notice in our study, this activity has a strong relation- ship with other activities. A development loop among Testing, Review, Elaboration, and Development activities is established to construct an effective and well-defined JIT requirement. During the interaction among these activities, JIT requirements and their implementation progress gradually.
Develop and Commit the Patch. In this activity, the developer basically transforms his understanding about the requirement specification, which is shaped through his own experience and others’ feedback, to code and subsequently pushes the changes to the remote repository. The original reporter plays a vital role in developing the code. However, following the nature of OSS projects, other developers are also considerably involved in the activity. During the discussion, remaining developers can either give valuable suggestions (e.g., LUCENE-2127) or develop their own implementation and commit to the development repository (e.g., MYLYN- 256699). As the requirement becomes more mature, the imple-
mentation also progresses to adapt with constructive feedback from reviewers.
Testing. The testing activity takes place after a developer commits the code in order to examine the implementation and provide helpful feedback. It includes but not limited to:
• Functionality Testing - justify that the new feature oper- ates in an expected manner (all the studied requirements)
• GUI Testing - make sure that the GUI is consistent with the existing system and the design elements display in an
expected manner (e.g., MYLYN-256699)
• Performance Testing - verify the efficiency of the system
with the new implementation (e.g., LUCENE-2127)
• System Consistency Testing - verify that the newly im- plemented feature follows and utilizes existing system
designs (all the studied requirements)
Voting. After finalizing the requirement specification and
implementation, one last step is conducted to decide if the patch should be released to public or not. The voting process can take place over IRC, on mailing lists, or even in issue comments. For example, in LUCENE, an email is sent with a subject starting with [VOTE] to the mailing list calling for a vote. If all members vote for it, the patch will be integrated into the released version. Otherwise, if any member objects the patch, he/she needs to deliver convincing reasons and must provide an alternative implementation (as stated in the Apache Foundation Software website). The substitution will then be reviewed and examined for its feasibility. If passed, a new issue will be created triggering the lifecycle of a new requirement.
We, however, did not observe any replacement for the JIT requirements we studied. One underlying rationale we observe is that most of the developers involved in the feature already participated in the discussion over the issue tracking systems. They examined the feasibility of the feature and provided feed- back. That resulted in a mature fully-developed specification, making consensus in the voting process inevitable.
B. Discussion
While conducting this preliminary research, we have dis- covered encouraging insights about the activities that drive the development of JIT requirements, thereby leading to the refinement process we have presented in this paper. This is a generalized process intended to be applicable beyond the six functional and non-functional JIT requirements we have studied. We notice a significant association among activities that gradually shapes a complete JIT requirement.
Research on JIT requirements is at the early of its dawn and this study aims to further expand understanding about the JIT aspects. Nonetheless, due to limited scope of this paper, the number of JIT requirements studied is yet very small. The critical sampling technique [12] has been used to seek for interesting patterns of functional and non-function JIT requirements. However, our number is constrained compared to the substantial amount of requirements our studied projects possess. In addition, with the studied non-functional JIT requirements, we notice that the developers mainly focus on implementation refinement rather than requirement elaboration
(e.g., FIREFOX-767676, LUCENE-2127, MYLYN-116487). It should be noted that we have chosen non-functional require- ments with a variety of focus, including security, performance and testability, so that the observation is broadly generalized. Such observation inspires us to formulate following questions regarding JIT requirements and our refinement process.
• Q1: How general the refinement process is? Is it possible to apply this process to a variety of JIT requirements?
• Q2: Is there any distinction between the elaboration pro-
cesses of functional and non-functional JIT requirements?
V. LIMITATION AND CONCLUSION
In this case study, we have analyzed the refinement and res- olution of both functional and non-functional JIT requirements in three large OSS systems. We showed how JIT requirements evolve through a set of activities with the supportive collabora- tion from developers in OSS communities. As our findings are based on only three subject systems with collected data mainly from developers’ comments, further comprehensive studies are required to strengthen our results.
In future, we plan to focus on broadening the scope of our study by examining the proposed refinement process in term of a wider range of requirements for more OSS projects. Another research direction we consider is assessing quality of JIT requirements when they follow the refinement process. The questions we plan to address are: Do the quality of JIT requirements really improved if they follow the refinement process? If so, how better they are compared to the ones that do not comply with the activities in the process?
REFERENCES
[1] W. Scacchi, C. Jensen, J. Noll, and M. Elliott, “Multi-modal modeling, analysis and validation of open source software requirements processes,” in International conference on Open Source Systems, vol. 1, no. 3, Genoa, Italy, 2005, pp. 49–63.
[2] N.A.ErnstandG.C.Murphy,“Casestudiesinjust-in-timerequirements analysis,” in 2012 Second IEEE International Workshop on Empirical Requirements Engineering (EmpiRE), Sept 2012, pp. 25–32.
[3] T.A.AlspaughandW.Scacchi,“Ongoingsoftwaredevelopmentwithout classical requirements,” in Requirements Engineering Conference (RE), 2013 21st IEEE International. IEEE, 2013, pp. 165–174.
[4] W.Scacchi,“Understandingtherequirementsfordevelopingopensource software systems,” IEE Proceedings - Software, vol. 149, no. 1, pp. 24– 39, Feb 2002.
[5] P. Heck and A. Zaidman, “Quality criteria for just-in-time requirements: just enough, just-in-time?” in 2015 IEEE Workshop on Just-In-Time Requirements Engineering (JITRE), Aug 2015, pp. 1–4.
[6] N. Niu, T. Bhowmik, H. Liu, and Z. Niu, “Traceability-enabled refac- toring for managing just-in-time requirements,” in 2014 IEEE 22nd International Requirements Engineering Conference (RE), Aug 2014, pp. 133–142.
[7] M. Lee, “Just-in-time requirements analysis-the engine that drives the planning game.” Agile Alliance, May 2002, pp. 25–32.
[8] T. Bhowmik and S. Reddivari, “Resolution trend of just-in-time require- ments in open source software development,” in 2015 IEEE Workshop on Just-In-Time Requirements Engineering (JITRE), Aug 2015, pp. 17–20.
[9] B. Nuseibeh and S. Easterbrook, “Requirements engineering: a roadmap,” in Proceedings of the Conference on the Future of Software Engineering. ACM, 2000, pp. 35–46.
[10] L. Chung, B. A. Nixon, E. Yu, and J. Mylopoulos, Non-functional requirements in software engineering. Springer Science & Business Media, 2012, vol. 5.
[11] T. Ohno, Toyota production system: beyond large-scale production. Productivity Press, 1988.
[12] M. Q. Patton, Qualitative Research and Evaluation Methods. SAGE Publications, 2001.
